<!doctype html>
<html>
   <head>
      <meta charset = "utf-8">
      <title>Procedural planet development</title>
      <script src="https://cdn.babylonjs.com/babylon.js"></script>
      <script type="application/fragmentShader" id="fragmentShaderCode">
        #ifdef GL_ES
            precision highp float;
        #endif

        varying vec2 vUV;
        varying vec3 p; // passed from vertex shader
        
        uniform float time;
        float fac = 0.1;

        void main(void) {
            vec3 pos =  p + vec3(0.5, 0., 0.5);
            gl_FragColor = vec4(0.33*(cos(fac*time) + 2.)*pos.x, 0.33*(sin(fac*time) + 2.)*pos.z, 0.5, 1.0); //
        }
      </script>
      <script type="application/vertexShader" id="vertexShaderCode">
          #ifdef GL_ES
              precision highp float;
          #endif

          // Attributes
          attribute vec3 position;
          attribute vec2 uv;

          // Uniforms
          uniform mat4 worldViewProjection;

          // Normal
          varying vec2 vUV;
          varying vec3 p; // position

          void main(void) {
          gl_Position = worldViewProjection * vec4(position, 1.0);

          vUV = uv;
          p = position; // spatial position of the actual geometry
          }
      </script>
      <style>
         html,body,canvas { margin: 0; padding: 0; width: 100%; height: 100%; font-size: 0; }
      </style>
   </head>
   
   <body>
      <canvas id = "renderCanvas"></canvas>
      <script type = "text/javascript">
         var canvas = document.getElementById("renderCanvas");
         var engine = new BABYLON.Engine(canvas, true);
         var createScene  = function() {
            var scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.2, 0.2, 0.25);
            
            // create a render target texture
            var renderTarget = new BABYLON.RenderTargetTexture('render to texture', 512, scene);
            scene.customRenderTargets.push(renderTarget); // add RTT to the scene
            
            // Parameters: name, alpha, beta, radius, target position, scene
            var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 10, new BABYLON.Vector3(0, 0, 0), scene);
            camera.mode = camera.ORTHOGRAPHIC_CAMERA;
            camera.orthoBottom = -0.5;
            camera.orthoTop = 0.5;
            camera.orthoLeft = -0.5;
            camera.orthoRight = 0.5;

            const plate = BABYLON.MeshBuilder.CreateGround("plate", {width: 1, height: 1}, scene); 
            
            // Built in Perlin noise
            //const noiseTexture = new BABYLON.NoiseProceduralTexture("perlin", 512, scene);
            //var material = new BABYLON.StandardMaterial("textureMaterial", scene);
            //material.specularColor = new BABYLON.Color3(0, 0, 0);
            //material.diffuseTexture = noiseTexture
            //plate.material = material;
        
            var shaderMaterial = new BABYLON.ShaderMaterial("shader", scene, {
                    vertexElement: "vertexShaderCode",
                    fragmentElement: "fragmentShaderCode",
                },
                {
                    attributes: ["position", "normal", "uv"],
                    uniforms: ["world", "worldView", "worldViewProjection", "view", "projection"]
            });
            //material.specularColor = new BABYLON.Color3(0, 0, 0);
            plate.material = shaderMaterial
            
            // add axes for debugging
            //const axes = new BABYLON.AxesViewer(scene, length_of_axes=1) // x: red, y: green z: blue.  The system is left handed with coordinate axes x-y-z !  Rotations follow the left hand rule
            
            // camera control
            // scene.activeCamera.attachControl(canvas);
            
            // prepare time variable to send to shaders
            var time = 0.;
            scene.registerBeforeRender(function() {
            plate.material.setFloat("time", time);
            time +=0.1;        
            });
            
            
            return scene;
         };
         var scene = createScene();
         engine.runRenderLoop(function() {
            scene.render();
         });
      </script>
   </body>
</html>





