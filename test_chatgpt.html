<!DOCTYPE html>
<html>
<head>
    <title>WebGL Example</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body onload="initializeWebGL();">

    <canvas id="c"></canvas>

    <script type="text/javascript">

        // Variables to hold WebGL context and shader programs
        let gl;
        let program;

        // Canvas dimensions
        let canvasWidth;
        let canvasHeight;

        // Arrays to store texture and buffer objects
        let textures = [];
        let buffers = [];

        // Initialize WebGL and setup resources
        function initializeWebGL() {
            // Get the WebGL context
            const canvas = document.getElementById('c');
            gl = canvas.getContext('webgl2');
            for (let k in gl) {
                // Rename WebGL functions and constants for better readability
                gl[k.split(/(^.|[^a-z])/).map(s => s[0]).join('')] = gl[k];
            }

            // Set canvas dimensions
            canvasWidth = innerWidth;
            canvasHeight = innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Create geometries, textures, and shaders
            for (let i = 0; i < 2; i++) {
                let x = createTexture(3553);
                textures[i] = createTexture();
                bindTexture(x, 0, 34836, canvasWidth, canvasHeight, 0, 6408, 5126, canvas);
                let f = createBuffer(36160);
                buffers[i] = createBuffer();
                generateMipmap(x);
                frameBufferTexture2D(f, 36064, x, textures[i], 0);
            }

            // Create the main shader program
            program = createShaderProgram();
            compileAndAttachShader(program, '%23version 300 es\nout highp vec4 O;uniform highp int F;uniform sampler2D B;void main(){O-=O;int k=169;');

            // Specify the main fragment shader code
            let fragmentShaderCode = `
                highp vec2 u=gl_FragCoord.yx,v,i;
                for(;k-->0;O+=vec4(0,v-i+v-v*${getTextureFetch()}.w,1)*${getTextureFetch()}.w/exp(dot(v,v))/3.142)
                    i=vec2(k/13,k%2513)-6.,v=i+${getTextureFetch()}.yz;
                O.yz/=O.w+1e-6;
                F>1?O:O+=vec4(0,u/1e3-${canvasHeight}./2e3,.3)`;
            compileAndAttachShader(program, fragmentShaderCode);

            // Compile and link the shader program
            linkShaderProgram(program);

            // Set uniform locations and attribute shader program
            getUniformLocationAndAttach(program, 'F');
            attachShader(program);

            // Set blending and enable the shader program
            setBlending();
            useShaderProgram(program);

            // Render the scene
            renderScene();
        }

        // Function to create texture objects
        function createTexture(target = gl.TEXTURE_2D) {
            let texture = gl.createTexture();
            gl.bindTexture(target, texture);
            return texture;
        }

        // Function to bind a texture to the framebuffer
        function bindTexture(texture, level, internalFormat, width, height, border, srcFormat, srcType, canvas) {
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, canvas);
        }

        // Function to generate mipmaps for a texture
        function generateMipmap(texture) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }

        // Function to create buffer objects
        function createBuffer(target = gl.ARRAY_BUFFER) {
            let buffer = gl.createBuffer();
            gl.bindBuffer(target, buffer);
            return buffer;
        }

        // Function to bind a texture to the framebuffer
        function frameBufferTexture2D(framebuffer, attachment, texture, level) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture, level);
        }

        // Function to create a shader program
        function createShaderProgram() {
            return gl.createProgram();
        }

        // Function to compile and attach a shader to the program
        function compileAndAttachShader(program, shaderSource) {
            let shaderType = (shaderSource.includes('out')) ? gl.FRAGMENT_SHADER : gl.VERTEX_SHADER;
            let shader = gl.createShader(shaderType);
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);
            gl.attachShader(program, shader);
        }

        // Function to link the shader program
        function linkShaderProgram(program) {
            gl.linkProgram(program);
        }

        // Function to get uniform location and attach to the program
        function getUniformLocationAndAttach(program, uniformName) {
            program[uniformName] = gl.getUniformLocation(program, uniformName);
        }

        // Function to attach the shader program
        function attachShader(program) {
            gl.attachShader(program, program.s);
        }

        // Function to set blending options
        function setBlending() {
            gl.uniform1i(gl.getUniformLocation(program, 'F'), i % 25500);
        }

        // Function to use the shader program
        function useShaderProgram(program) {
            gl.useProgram(program);
        }

        // Function to get the texture fetch expression
        function getTextureFetch() {
            return 'texelFetch(B, ivec2(i+u).yx, 0)';
        }

        // Function to render the scene
        function renderScene() {
            let i = 2;
            while (i--) {
                renderSceneStep(i % 2);
            }
            requestAnimationFrame(renderScene);
        }

        // Function to render a scene step
        function renderSceneStep(index) {
            let b = buffers[index];
            gl.uniform1i(program.F, i % 25500);
            bindFrameBuffer(b);
            bindTexture(textures[i % 2], 0);
            bindBuffer(buffers[i % 2], textures[i % 2]);
            drawArrays(4, 0, 3);
            bindTexture(textures[i % 2], 0);
            bindBuffer(buffers[index]);
            drawArrays();
        }

        // Function to bind the framebuffer
        function bindFrameBuffer(framebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        }

        // Function to bind a buffer to a texture
        function bindBuffer(buffer, texture) {
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);
            gl.uniform1i(gl.getUniformLocation(program, 'B'), texture);
        }

        // Function to draw arrays
        function drawArrays() {
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

    </script>
</body>
</html>