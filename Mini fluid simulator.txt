Shadertoy:

// Common 
#define M void mainImage(out vec4 r, vec2 u) { vec2 v, i = u-u; r -= r 
#define A texelFetch(iChannel0,ivec2(i+u),0) 

// Buffer A (iChannel0) 
M; for(int k=0; k++<196; 
v = A.xy+i, 
r += vec4(v-i + v-v*A.z,1,1) * A.z / exp(dot(v,v)) / 3.142) 
i = vec2(k%14,k/14)-7.; 
r.xy /= r.z + 1e-6; // add epsilon to avoid division by zero 
iFrame%500<2 ? r += vec4(u/1e3-.5,.3,0) : r;} 

// Image M-1.+A.z;}


Minimalist WebGL wrapper

data:text/html,<body onload="i=2;c.height=H=innerHeight;c.width=W=innerWidth;for(k in g=c.getContext`webgl2`)g[k.split(/(^.|[^a-z])/).map(s=>s[0]).join``]=g[k];with(g){for(e of geSuEx())geEx(e);P=crPr();for(X=[],B=[];i--;t=35632)biTe(x=3553,X[i]=crTe())|teIm2D(x,0,34836,W,H,0,6408,5126,c)|biFr(f=36160,B[i]=crFr())|geMi(x)|frTe2D(f,36064,x,X[i],0);A=`texelFetch(B,ivec2(i+u).yx,0)`;C=s=>shSo(S=crSh(t++),`%23version 300 es\nout highp vec4 O;uniform highp int F;uniform sampler2D B;void main(){O-=O;int k=169;${s};}`)|coSh(S)|atSh(P,S);C(`highp vec2 u=gl_FragCoord.yx,v,i;for(;k-->0;O+=vec4(0,v-i+v-v*${A}.w,1)*${A}.w/exp(dot(v,v))/3.142)i=vec2(k/13,k%2513)-6.,v=i+${A}.yz;O.yz/=O.w+1e-6;F>1?O:O+=vec4(0,u/1e3-${H}./2e3,.3)`);C`k=gl_VertexID;gl_Position=vec4(k*4&4,k*2&4,1,2)-1.`;R=b=>uniform1i(geUnLo(P,`F`),i%25500)|biFr(f,b)|biTe(x,X[i%2])|drAr(4,0,3);liPr(P);usPr(P)}L=_=>R(B[i++%2])|R()|requestAnimationFrame(L);L()"style=margin:0><canvas id=c>


<body onload="i=2;c.height=H=innerHeight;c.width=W=innerWidth;for(k in g=c.getContext`webgl2`)g[k.split(/(^.|[^a-z])/).map(s=>s[0]).join``]=g[k];with(g){for(e of geSuEx())geEx(e);P=crPr();for(X=[],B=[];i--;t=35632)biTe(x=3553,X[i]=crTe())|teIm2D(x,0,34836,W,H,0,6408,5126,c)|biFr(f=36160,B[i]=crFr())|geMi(x)|frTe2D(f,36064,x,X[i],0);A=`texelFetch(B,ivec2(i+u).yx,0)`;C=s=>shSo(S=crSh(t++),`%23version 300 es\nout highp vec4 O;uniform highp int F;uniform sampler2D B;void main(){O-=O;int k=169;${s};}`)|coSh(S)|atSh(P,S);C(`highp vec2 u=gl_FragCoord.yx,v,i;for(;k-->0;O+=vec4(0,v-i+v-v*${A}.w,1)*${A}.w/exp(dot(v,v))/3.142)i=vec2(k/13,k%2513)-6.,v=i+${A}.yz;O.yz/=O.w+1e-6;F>1?O:O+=vec4(0,u/1e3-${H}./2e3,.3)`);C`k=gl_VertexID;gl_Position=vec4(k*4&4,k*2&4,1,2)-1.`;R=b=>uniform1i(geUnLo(P,`F`),i%25500)|biFr(f,b)|biTe(x,X[i%2])|drAr(4,0,3);liPr(P);usPr(P)}L=_=>R(B[i++%2])|R()|requestAnimationFrame(L);L()"style=margin:0><canvas id=c>



ChatGPT refactored version:

<!DOCTYPE html>
<html>
<head>
    <title>WebGL Example</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body onload="initializeWebGL();">

    <canvas id="c"></canvas>

    <script type="text/javascript">

        // Variables to hold WebGL context and shader programs
        let gl;
        let program;

        // Canvas dimensions
        let canvasWidth;
        let canvasHeight;

        // Arrays to store texture and buffer objects
        let textures = [];
        let buffers = [];

        // Initialize WebGL and setup resources
        function initializeWebGL() {
            // Get the WebGL context
            const canvas = document.getElementById('c');
            gl = canvas.getContext('webgl2');
            for (let k in gl) {
                // Rename WebGL functions and constants for better readability
                gl[k.split(/(^.|[^a-z])/).map(s => s[0]).join('')] = gl[k];
            }

            // Set canvas dimensions
            canvasWidth = innerWidth;
            canvasHeight = innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Create geometries, textures, and shaders
            for (let i = 0; i < 2; i++) {
                let x = createTexture(3553);
                textures[i] = createTexture();
                bindTexture(x, 0, 34836, canvasWidth, canvasHeight, 0, 6408, 5126, canvas);
                let f = createBuffer(36160);
                buffers[i] = createBuffer();
                generateMipmap(x);
                frameBufferTexture2D(f, 36064, x, textures[i], 0);
            }

            // Create the main shader program
            program = createShaderProgram();
            compileAndAttachShader(program, '%23version 300 es\nout highp vec4 O;uniform highp int F;uniform sampler2D B;void main(){O-=O;int k=169;');

            // Specify the main fragment shader code
            let fragmentShaderCode = `
                highp vec2 u=gl_FragCoord.yx,v,i;
                for(;k-->0;O+=vec4(0,v-i+v-v*${getTextureFetch()}.w,1)*${getTextureFetch()}.w/exp(dot(v,v))/3.142)
                    i=vec2(k/13,k%2513)-6.,v=i+${getTextureFetch()}.yz;
                O.yz/=O.w+1e-6;
                F>1?O:O+=vec4(0,u/1e3-${canvasHeight}./2e3,.3)`;
            compileAndAttachShader(program, fragmentShaderCode);

            // Compile and link the shader program
            linkShaderProgram(program);

            // Set uniform locations and attribute shader program
            getUniformLocationAndAttach(program, 'F');
            attachShader(program);

            // Set blending and enable the shader program
            setBlending();
            useShaderProgram(program);

            // Render the scene
            renderScene();
        }

        // Function to create texture objects
        function createTexture(target = gl.TEXTURE_2D) {
            let texture = gl.createTexture();
            gl.bindTexture(target, texture);
            return texture;
        }

        // Function to bind a texture to the framebuffer
        function bindTexture(texture, level, internalFormat, width, height, border, srcFormat, srcType, canvas) {
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, canvas);
        }

        // Function to generate mipmaps for a texture
        function generateMipmap(texture) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }

        // Function to create buffer objects
        function createBuffer(target = gl.ARRAY_BUFFER) {
            let buffer = gl.createBuffer();
            gl.bindBuffer(target, buffer);
            return buffer;
        }

        // Function to bind a texture to the framebuffer
        function frameBufferTexture2D(framebuffer, attachment, texture, level) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture, level);
        }

        // Function to create a shader program
        function createShaderProgram() {
            return gl.createProgram();
        }

        // Function to compile and attach a shader to the program
        function compileAndAttachShader(program, shaderSource) {
            let shaderType = (shaderSource.includes('out')) ? gl.FRAGMENT_SHADER : gl.VERTEX_SHADER;
            let shader = gl.createShader(shaderType);
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);
            gl.attachShader(program, shader);
        }

        // Function to link the shader program
        function linkShaderProgram(program) {
            gl.linkProgram(program);
        }

        // Function to get uniform location and attach to the program
        function getUniformLocationAndAttach(program, uniformName) {
            program[uniformName] = gl.getUniformLocation(program, uniformName);
        }

        // Function to attach the shader program
        function attachShader(program) {
            gl.attachShader(program, program.s);
        }

        // Function to set blending options
        function setBlending() {
            gl.uniform1i(gl.getUniformLocation(program, 'F'), i % 25500);
        }

        // Function to use the shader program
        function useShaderProgram(program) {
            gl.useProgram(program);
        }

        // Function to get the texture fetch expression
        function getTextureFetch() {
            return 'texelFetch(B, ivec2(i+u).yx, 0)';
        }

        // Function to render the scene
        function renderScene() {
            let i = 2;
            while (i--) {
                renderSceneStep(i % 2);
            }
            requestAnimationFrame(renderScene);
        }

        // Function to render a scene step
        function renderSceneStep(index) {
            let b = buffers[index];
            gl.uniform1i(program.F, i % 25500);
            bindFrameBuffer(b);
            bindTexture(textures[i % 2], 0);
            bindBuffer(buffers[i % 2], textures[i % 2]);
            drawArrays(4, 0, 3);
            bindTexture(textures[i % 2], 0);
            bindBuffer(buffers[index]);
            drawArrays();
        }

        // Function to bind the framebuffer
        function bindFrameBuffer(framebuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        }

        // Function to bind a buffer to a texture
        function bindBuffer(buffer, texture) {
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);
            gl.uniform1i(gl.getUniformLocation(program, 'B'), texture);
        }

        // Function to draw arrays
        function drawArrays() {
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

    </script>
</body>
</html>





ChatGPT translates to shadertoy to babylonjs:

// Vertex shader
precision highp float;

// Uniforms
uniform mat4 viewProjection;
uniform vec2 iResolution;

// Vertex attributes
attribute vec2 position;

void main(void) {
    gl_Position = viewProjection * vec4(position, 0.0, 1.0);
}





// Fragment shader
precision highp float;

// Uniforms
uniform float iTime;
uniform vec2 iResolution;
uniform sampler2D iChannel0;

// Function to fetch pixel data
vec4 texelFetch(sampler2D textureSampler, ivec2 texCoord) {
    return texture2D(textureSampler, (texCoord + 0.5) / iResolution);
}

// Function to generate random number between 0 and 1
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void mainImage(out vec4 fragColor, vec2 fragCoord) {
    // Generate random noise for initialization
    vec2 uv = fragCoord / iResolution;
    float randomValue = random(uv);

    // Set the output color to the random value
    fragColor = vec4(randomValue, randomValue, randomValue, 1.0);
}

void main(void) {
    vec2 uv = gl_FragCoord.xy / iResolution.xy;
    mainImage(gl_FragColor, uv);
}




// must set up iTime, iResolution, and iChannel0 


for iResolution:

customMaterial.setUniform("iResolution", new BABYLON.Vector2(engine.getRenderWidth(), engine.getRenderHeight()));